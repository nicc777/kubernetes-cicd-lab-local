<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@1295.v395eb_7400005">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@2.2131.vb_9788088fdb_5"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@2.2131.vb_9788088fdb_5">
      <jobProperties/>
      <triggers/>
      <parameters/>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty plugin="gitlab-plugin@1.7.13">
      <gitLabConnection>gitlab-lab</gitLabConnection>
      <jobCredentialId></jobCredentialId>
      <useAlternativeCredential>false</useAlternativeCredential>
    </com.dabsquared.gitlabjenkins.connection.GitLabConnectionProperty>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers>
        <com.dabsquared.gitlabjenkins.GitLabPushTrigger plugin="gitlab-plugin@1.7.13">
          <spec></spec>
          <triggerOnPush>false</triggerOnPush>
          <triggerToBranchDeleteRequest>false</triggerToBranchDeleteRequest>
          <triggerOnMergeRequest>true</triggerOnMergeRequest>
          <triggerOnlyIfNewCommitsPushed>false</triggerOnlyIfNewCommitsPushed>
          <triggerOnPipelineEvent>false</triggerOnPipelineEvent>
          <triggerOnAcceptedMergeRequest>true</triggerOnAcceptedMergeRequest>
          <triggerOnClosedMergeRequest>true</triggerOnClosedMergeRequest>
          <triggerOnApprovedMergeRequest>true</triggerOnApprovedMergeRequest>
          <triggerOpenMergeRequestOnPush>never</triggerOpenMergeRequestOnPush>
          <triggerOnNoteRequest>true</triggerOnNoteRequest>
          <noteRegex>Jenkins please retry a build</noteRegex>
          <ciSkip>true</ciSkip>
          <skipWorkInProgressMergeRequest>true</skipWorkInProgressMergeRequest>
          <labelsThatForcesBuildIfAdded></labelsThatForcesBuildIfAdded>
          <setBuildDescription>true</setBuildDescription>
          <branchFilterType>All</branchFilterType>
          <includeBranchesSpec></includeBranchesSpec>
          <excludeBranchesSpec></excludeBranchesSpec>
          <sourceBranchRegex></sourceBranchRegex>
          <targetBranchRegex></targetBranchRegex>
          <secretToken>{AQAAABAAAAAwct0mWDLxAIRaWLmbRZXHhYxO1oCOm2YMMKjkKtsbQ1Q3WSH3Wy2hcOt5RAE2o33HeQhCvgo4nzjFNos5GC9a1g==}</secretToken>
          <pendingBuildName></pendingBuildName>
          <cancelPendingBuildsOnUpdate>false</cancelPendingBuildsOnUpdate>
        </com.dabsquared.gitlabjenkins.GitLabPushTrigger>
      </triggers>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@3659.v582dc37621d8">
    <script>def REPO_APP_DIR = &apos;&apos;
def REPO_MAINT_DIR = &apos;&apos;
def skipRemainingStages = false
def APP_SOURCE_BRANCH = &apos;main&apos;

pipeline {
    agent { node { label &quot;docker-build-node&quot; }}
    stages {
        stage(&apos;checkout-application-branch&apos;) {
            steps {
                updateGitlabCommitStatus name: &apos;checkout&apos;, state: &apos;running&apos;
                echo &quot;Checkout Application Repo&quot;

                script {
                    // These are variables set by the GitLab Plugin
                    try {
                        echo &quot;gitlabBranch            : ${gitlabBranch}\n&quot; +
                             &quot;gitlabSourceBranch      : ${gitlabSourceBranch}\n&quot; +
                             &quot;gitlabSourceRepoName    : ${gitlabSourceRepoName}\n&quot; +
                             &quot;gitlabMergeRequestId    : ${gitlabMergeRequestId}\n&quot; +
                             &quot;gitlabTargetBranch      : ${gitlabTargetBranch}\n&quot; +
                             &quot;gitlabTriggerPhrase     : ${gitlabTriggerPhrase}\n&quot;
                        APP_SOURCE_BRANCH = gitlabSourceBranch
                    } catch (Exception e) {
                        updateGitlabCommitStatus name: &apos;checkout&apos;, state: &apos;failed&apos;
                        skipRemainingStages = true
                    }   
                }
                
                script {
                    def pwd = sh( 
                        script: &apos;mkdir app_dir &amp;&amp; cd app_dir &amp;&amp; pwd&apos;,
                        returnStdout: true
                    ).trim()
                    REPO_APP_DIR = pwd
                }
                
                dir(REPO_APP_DIR){
                    git branch: APP_SOURCE_BRANCH, credentialsId: &apos;jenkins-gitlab-ssh&apos;, url: &apos;git@gitlab:lab/application-repo-01.git&apos;
                }
                
                script {
                    echo &quot;REPO_APP_DIR: ${REPO_APP_DIR}&quot;
                    echo &quot;Checking branch ${APP_SOURCE_BRANCH}&quot;
                    def actual_branch = sh(
                        script: &apos;git status| head -1&apos;,
                        returnStdout: true
                    ).trim()
                    echo &quot;actual_branch: ${actual_branch}&quot;
                }
                
                echo &quot;Checkout CI Repo&quot;
            }
        }
        stage(&apos;checkout-maintenance-branch&apos;) {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                echo &quot;Checkout Maintenance Repo&quot;

                script {
                    def pwd = sh( 
                        script: &apos;mkdir maint_repo &amp;&amp; cd maint_repo &amp;&amp; pwd&apos;,
                        returnStdout: true
                    ).trim()
                    REPO_MAINT_DIR = pwd
                    echo &quot;REPO_MAINT_DIR: ${REPO_MAINT_DIR}&quot;
                }

                dir(REPO_MAINT_DIR){
                    git branch: &apos;main&apos;, credentialsId: &apos;jenkins-gitlab-ssh&apos;, url: &apos;git@gitlab:lab/deployment-maintenance.git&apos;
                }
                
                echo &quot;Checkout CI Repo&quot;
                updateGitlabCommitStatus name: &apos;checkout&apos;, state: &apos;success&apos;
            }
        }
        stage(&apos;generate-helm-charts&apos;) {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                updateGitlabCommitStatus name: &apos;generate-helm-charts&apos;, state: &apos;running&apos;
                echo &quot;Generate Helm Charts&quot;
                echo &quot;REPO_APP_DIR: ${REPO_APP_DIR}&quot;
                echo &quot;REPO_MAINT_DIR: ${REPO_MAINT_DIR}&quot;
                script {
                    try {
                        dir(REPO_MAINT_DIR){
                            def output = sh( 
                                script: &quot;sh run.sh application_helm_integration.py ${env.BUILD_NUMBER} ${REPO_APP_DIR} ${APP_SOURCE_BRANCH} ${REPO_MAINT_DIR} lab awesome-application &apos;http://gitlab:8080/lab/${gitlabSourceRepoName}.git&apos; &apos;http://gitlab:8080/lab/deployment-maintenance.git&apos;&quot;,
                                returnStdout: true
                            ).trim()
                            echo &quot;output: ${output}&quot;
                        }
                        updateGitlabCommitStatus name: &apos;generate-helm-charts&apos;, state: &apos;success&apos;
                    } catch (Exception e) {
                        updateGitlabCommitStatus name: &apos;generate-helm-charts&apos;, state: &apos;failed&apos;
                        skipRemainingStages = true
                    }       
                }
            }
        }
        stage(&apos;commit-helm-charts&apos;) {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                updateGitlabCommitStatus name: &apos;commit-helm-charts&apos;, state: &apos;running&apos;
                echo &quot;Commit Helm Charts&quot;
                /*
                sshagent (credentials: [&apos;git-ssh-credentials-ID&apos;]) {
                    sh(&quot;git tag -a some_tag -m &apos;Jenkins&apos;&quot;)
                    sh(&apos;git push &lt;REPO&gt; --tags&apos;)
                }
                */
                updateGitlabCommitStatus name: &apos;commit-helm-charts&apos;, state: &apos;success&apos;
            }
        }
        stage(&apos;cleanup&apos;) {
            when {
                expression {
                    !skipRemainingStages
                }
            }
            steps {
                updateGitlabCommitStatus name: &apos;cleanup&apos;, state: &apos;running&apos;
                echo &quot;DONE&quot;
                updateGitlabCommitStatus name: &apos;cleanup&apos;, state: &apos;success&apos;
            }
        }
    }
}</script>
    <sandbox>false</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>